"""
Streamlit two-page app:
- Page 1: collect user input and call Databricks pipeline (simulated)
- Page 2: preview generated email, optionally edit, and send with attachments

Best practices:
- Use environment variables / Streamlit secrets for credentials
- Validate inputs
- Keep attachments in memory (BytesIO)
- Use TLS for SMTP
- Clear logging and error handling
"""

import os
import io
import logging
import base64
from typing import List, Dict, Any, Tuple
from dataclasses import dataclass

import pandas as pd
import streamlit as st
from email.message import EmailMessage
import smtplib

# ---------- Configuration & Logging ----------
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Read secrets from environment (or Streamlit secrets)
SMTP_HOST = os.getenv("SMTP_HOST")
SMTP_PORT = int(os.getenv("SMTP_PORT", "587"))
SMTP_USER = os.getenv("SMTP_USER")
SMTP_PASS = os.getenv("SMTP_PASS")
SENDER_EMAIL = os.getenv("SENDER_EMAIL")

# Databricks placeholders (replace with real values)
DATABRICKS_HOST = os.getenv("DATABRICKS_HOST")
DATABRICKS_TOKEN = os.getenv("DATABRICKS_TOKEN")

# ---------- Data structures ----------
@dataclass
class Attachment:
    filename: str
    content_bytes: bytes
    mime_type: str = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"

@dataclass
class GeneratedEmail:
    sender: str
    to: List[str]
    cc: List[str]
    subject: str
    body: str
    attachments: List[Attachment]

# ---------- Helper functions ----------
def validate_email_list(raw: str) -> List[str]:
    """Simple CSV split and strip. For production use a robust validator."""
    if not raw:
        return []
    return [e.strip() for e in raw.split(",") if e.strip()]

def create_sample_excel(name: str, rows: int = 5) -> bytes:
    """Create a sample Excel file in memory for demo/testing."""
    df = pd.DataFrame({
        "Name": [f"{name}_{i}" for i in range(rows)],
        "Value": list(range(rows))
    })
    buffer = io.BytesIO()
    with pd.ExcelWriter(buffer, engine="openpyxl") as writer:
        df.to_excel(writer, index=False, sheet_name="Sheet1")
    buffer.seek(0)
    return buffer.read()

def fetch_from_databricks(user_inputs: Dict[str, Any]) -> GeneratedEmail:
    """
    Simulated call to Databricks pipeline.
    Replace this with your Databricks REST API call and parsing logic.
    The function returns a GeneratedEmail object with attachments as bytes.
    """
    # Example: build a templated email using user inputs
    recipient = user_inputs.get("recipient_email", "recipient@example.com")
    cc = user_inputs.get("cc_email", "")
    name = user_inputs.get("name", "Valued Customer")
    product = user_inputs.get("product", "Product X")

    subject = f"Update on {product} for {name}"
    body = (
        f"Hi {name},\n\n"
        f"This is an automated update generated by our Databricks pipeline.\n\n"
        f"Summary:\n"
        f"- Product: {product}\n"
        f"- Next steps: Please review the attached report.\n\n"
        f"Regards,\n"
        f"Automated System\n"
    )

    # Create sample attachments (Excel)
    attachments = [
        Attachment(filename="report_summary.xlsx", content_bytes=create_sample_excel("summary", 8)),
        Attachment(filename="detailed_metrics.xlsx", content_bytes=create_sample_excel("metrics", 12)),
    ]

    generated = GeneratedEmail(
        sender=SENDER_EMAIL or "no-reply@example.com",
        to=[recipient],
        cc=validate_email_list(cc),
        subject=subject,
        body=body,
        attachments=attachments
    )
    logger.info("Fetched simulated email from Databricks")
    return generated

def send_email_via_smtp(email_obj: GeneratedEmail, override_body: str = None) -> Tuple[bool, str]:
    """
    Send email using SMTP with attachments.
    Returns (success, message).
    """
    if not SMTP_HOST or not SMTP_USER or not SMTP_PASS:
        return False, "SMTP configuration missing. Set SMTP_HOST, SMTP_USER, SMTP_PASS."

    msg = EmailMessage()
    msg["From"] = email_obj.sender
    msg["To"] = ", ".join(email_obj.to)
    if email_obj.cc:
        msg["Cc"] = ", ".join(email_obj.cc)
    msg["Subject"] = email_obj.subject
    body = override_body if override_body is not None else email_obj.body
    msg.set_content(body)

    # Attach files
    for att in email_obj.attachments:
        maintype, subtype = att.mime_type.split("/", 1) if "/" in att.mime_type else ("application", "octet-stream")
        msg.add_attachment(att.content_bytes, maintype=maintype, subtype=subtype, filename=att.filename)

    recipients = email_obj.to + email_obj.cc
    try:
        with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as server:
            server.starttls()
            server.login(SMTP_USER, SMTP_PASS)
            server.send_message(msg, from_addr=email_obj.sender, to_addrs=recipients)
        logger.info("Email sent successfully to %s", recipients)
        return True, f"Email sent to {', '.join(recipients)}"
    except Exception as e:
        logger.exception("Failed to send email")
        return False, f"Failed to send email: {e}"

def bytes_to_download_link(b: bytes, filename: str, label: str = "Download") -> str:
    """Return an HTML anchor tag for downloading bytes in Streamlit (safe for small files)."""
    b64 = base64.b64encode(b).decode()
    href = f'<a href="data:application/octet-stream;base64,{b64}" download="{filename}">{label}</a>'
    return href

# ---------- Streamlit UI ----------
st.set_page_config(page_title="Email Generator", layout="centered")

# Simple multipage using query params / session_state
PAGES = ["input", "preview"]

# Initialize session state
if "page" not in st.session_state:
    st.session_state.page = "input"
if "generated_email" not in st.session_state:
    st.session_state.generated_email = None  # type: ignore
if "editable_body" not in st.session_state:
    st.session_state.editable_body = None
if "attachments" not in st.session_state:
    st.session_state.attachments = []  # type: ignore

def go_to(page: str):
    st.session_state.page = page

# ---------- Page 1: Input / Logic ----------
def page_input():
    st.header("Step 1 — Provide details to generate the email")
    st.markdown("Fill the fields below and click **Generate**. This will call the Databricks pipeline and return a templated email with attachments.")

    with st.form("input_form", clear_on_submit=False):
        name = st.text_input("Recipient name", value="John Doe")
        recipient_email = st.text_input("Recipient email", value="recipient@example.com")
        cc_email = st.text_input("CC emails (comma separated)", value="cc1@example.com, cc2@example.com")
        product = st.text_input("Product / Topic", value="Quarterly Report")
        notes = st.text_area("Optional notes for pipeline", value="Please include latest metrics.")
        submitted = st.form_submit_button("Generate email")

    if submitted:
        # Basic validation
        if not recipient_email:
            st.error("Recipient email is required.")
            return
        user_inputs = {
            "name": name,
            "recipient_email": recipient_email,
            "cc_email": cc_email,
            "product": product,
            "notes": notes
        }

        # Call Databricks pipeline (simulated)
        try:
            with st.spinner("Calling Databricks pipeline..."):
                generated = fetch_from_databricks(user_inputs)
            # Save to session state
            st.session_state.generated_email = generated
            st.session_state.editable_body = generated.body
            st.session_state.attachments = generated.attachments.copy()
            st.success("Email generated. Redirecting to preview...")
            go_to("preview")
            st.rerun()
        except Exception as e:
            logger.exception("Error fetching from Databricks")
            st.error(f"Failed to generate email: {e}")

# ---------- Page 2: Preview & Send ----------
def page_preview():
    st.header("Step 2 — Preview, edit (optional), and send")
    if not st.session_state.generated_email:
        st.info("No generated email found. Please go to the Input page to generate one.")
        if st.button("Go to Input"):
            go_to("input")
            st.rerun()
        return

    gen: GeneratedEmail = st.session_state.generated_email

    # Top metadata
    st.subheader("Email metadata")
    col1, col2 = st.columns([2, 1])
    with col1:
        st.markdown(f"**From:** {gen.sender}")
        st.markdown(f"**To:** {', '.join(gen.to)}")
        st.markdown(f"**CC:** {', '.join(gen.cc) if gen.cc else '—'}")
    with col2:
        st.markdown(f"**Subject:** {gen.subject}")

    st.markdown("---")

    # Checkbox: send as-is (checked by default)
    send_as_is = st.checkbox("Send generated content as-is (uncheck to edit)", value=True, key="send_as_is_checkbox")

    # Body preview / editable area
    st.markdown("**Email body**")
    # Use a fixed-height text area with scroll; if editable, enable editing
    if send_as_is:
        # show non-editable text area (disabled)
        st.text_area("Generated body (read-only)", value=st.session_state.editable_body or gen.body, height=300, disabled=True)
    else:
        # editable
        new_body = st.text_area("Edit email body", value=st.session_state.editable_body or gen.body, height=300)
        st.session_state.editable_body = new_body

    st.markdown("---")

    # Attachments preview and management
    st.subheader("Attachments")
    st.markdown("Attachments returned by the pipeline. You can remove any before sending.")
    attachments: List[Attachment] = st.session_state.attachments or []
    to_remove = []
    for idx, att in enumerate(attachments):
        cols = st.columns([6, 2, 2])
        cols[0].markdown(f"**{att.filename}**")
        # Provide a small download link
        cols[1].markdown(bytes_to_download_link(att.content_bytes, att.filename, label="Download"), unsafe_allow_html=True)
        if cols[2].button("Remove", key=f"remove_{idx}"):
            to_remove.append(idx)
    # Remove selected attachments
    if to_remove:
        st.session_state.attachments = [a for i, a in enumerate(attachments) if i not in to_remove]
        st.rerun()

    st.markdown("---")

    # Optional: allow user to upload additional attachments
    st.subheader("Add attachments (optional)")
    uploaded_files = st.file_uploader("Upload Excel files to attach (optional)", accept_multiple_files=True, type=["xlsx", "xls"])
    if uploaded_files:
        for uf in uploaded_files:
            content = uf.read()
            st.session_state.attachments.append(Attachment(filename=uf.name, content_bytes=content))
        st.success(f"Added {len(uploaded_files)} file(s).")

    st.markdown("---")

    # Send form
    with st.form("send_form"):
        # Allow editing subject or recipients if needed (optional)
        edit_subject = st.text_input("Subject", value=gen.subject)
        edit_to = st.text_input("To (comma separated)", value=", ".join(gen.to))
        edit_cc = st.text_input("CC (comma separated)", value=", ".join(gen.cc))
        send_button = st.form_submit_button("Send email")

    if send_button:
        # Validate recipients
        to_list = validate_email_list(edit_to)
        cc_list = validate_email_list(edit_cc)
        if not to_list:
            st.error("At least one recipient is required in To.")
        else:
            # Build email object to send
            email_to_send = GeneratedEmail(
                sender=gen.sender,
                to=to_list,
                cc=cc_list,
                subject=edit_subject,
                body=st.session_state.editable_body if not send_as_is else gen.body,
                attachments=st.session_state.attachments.copy()
            )
            with st.spinner("Sending email..."):
                success, msg = send_email_via_smtp(email_to_send, override_body=None)
            if success:
                st.success(msg)
            else:
                st.error(msg)

    st.markdown("---")
    if st.button("Back to Input"):
        go_to("input")
        st.rerun()

# ---------- Router ----------
if st.session_state.page == "input":
    page_input()
else:
    page_preview()
